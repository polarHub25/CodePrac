
https://leetcode.com/problems/longest-palindromic-substring/description/

시간복잡도 : O(n^2) -> 각 문자를 중심으로 확장하여 검사하는것과 각 중심에서 좌우로 확장하는데 최악의 경우 O(n) 
공간복잡도 : o(1) -> 추가적인 메모리를 사용하지않으므로 O(1) 
문자열의 각 문자를 중심으로 좌우로 확장하면서 가장 긴 좌우대칭 문자열을 찾는 방식 

for -> 문자열의 각 위치를 중심으로 팰린드롬을 찾는 작업 / i는 문자열의 임의의 중심점 
while -> 주어진 중심 i에서 팰린드룸이 될수 있는 최대 길이로 확장 -> 최대 길이를 반환 고로 right - left - 1


> 시간복잡도
- 알고리즘이 실행되는데 걸리는 시간
- 
> 공간복잡도
- 알고리즘이 실행되는 동안 필요한 메모리 공간 



## Sliding window 
https://leetcode.com/problems/longest-substring-without-repeating-characters/description/

> 슬라이딩 윈도우 사용 이유
- 연속된 데이터를 효율적으로 처리할 수 있는 기법
- 연속된 부분 배열이나 부분 문자열에서 특정 조건을 만족하는 최대/최소 길이를 구할 때 유용
- 중복되지 않는 가장 긴 문자열을 검색 하기 위해 투 포인터를 사용해 설정
- 슬라이딩 윈도우는 문자열을 한번만 순회하므로 시간복잡도를 O(n)으로 가능
> HashMap 사용 이유
- 각 문자의 인덱스를 빠르게 조회하고 업데이트 하기 위해서
- 해시맵의 시간복잡도는 조회, 삽입이 평균적으로 O(1)
- 키-값 구조로 저장하는 자료구조로 해시 테이블을 기반으로 함. 키를 해시함수로 변환해서 해시 값을 얻고, 해당 해시값을 배열의 인덱스로 사용해 데이터를 저장하거나 조회.
- 해시 충돌은 체이닝 방식을 사용해 처리하며, java 8 부터는 연결 리스트가 일정 크기를 넘으로 레드-블랙 트리로 변환하여 검색 성능이 O(log n)으로 개선
- 해시 충돌 : 서로 다른 두개의 키가 동일한 해시 값을 가지는 경우 / 해시 함수는 키를 입력으로 받아 해시코드를 생성하고 이 해시코드의 나머지 값을 이용해 배열의 인덱스를 결정하는데 이떄 서로 다른 키들이 동일한 해시코드로 같은 배열 인덱스를 가리킬 수 있음 
> 시간 복잡도 / 공간 복잡도
- 시간 복잡도 : O(n)
- 공간 복잡도 : O(min(n,m)) -> n : 문자열 길이 , m : 가능한 문자 집합의 크기
> "Math.max(start, map.get(currentChar) + 1)" 로 start 변수를 설정한 이유는?
- 중복된 문자가 발생했을 경우 중복이 발생한 다음 바로 위치로 이동해야하므로 저렇게 설정
- max 설정 이유는 start 포인터가 현재 위치보다 뒤로 가지 않도록 하기 위해서
- 예를 들어서 abba 데이터로 코드를 돌려보면, start 값은 이미 b에서 중복이 되어서 start는 2가 되는데 마지막 a에서 max를 안해주면 start는 기존 a의 인덱스 값인 0에서 +1를 해준1로 뒤로 가게된다. 이걸 방지하기 위해 max로 설정 
> Start가 이동하지 않는 경우
- 중복된 문자가 발생하지 않은 경우 


